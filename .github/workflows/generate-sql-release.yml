name: Generate SQL Release Bundle

on:
  pull_request:
    branches:
      - Release
    types: [closed]
  workflow_dispatch: # This enables the manual "Run" button

jobs:
  generate-bundle:
    if: github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: Release  # Ensure we are working on the Release branch files
          fetch-depth: 0 # This fetches all branches and history

      - name: Process SQL Changes
        id: process_sql
        shell: bash
        run: |
          # 1. Handle Git History safely
          # Only unshallow if the repo actually is shallow
          if [ -f .git/shallow ]; then
            git fetch --unshallow --tags
          else
            git fetch --all --tags
          fi
          
          LAST_RELEASE_TS=""

          # 2. Check for Output folder without triggering ls immediately
          if [ -d "Output" ]; then
              echo "Output directory exists."
              
              # Get the newest file by name into a variable safely
              # 2>/dev/null hides the error if the folder is empty
              LAST_FILE=$(ls -1 Output/ 2>/dev/null | grep "__" | sort -r | head -n 1 || echo "")
              
              if [ -n "$LAST_FILE" ]; then
                  echo "Found last release: $LAST_FILE"
                  RAW_TS=$(echo "$LAST_FILE" | cut -d'_' -f1)
                  
                  # Reformat for Git: YYYY-MM-DD HH:MM:SS
                  LAST_RELEASE_TS="${RAW_TS:0:4}-${RAW_TS:4:2}-${RAW_TS:6:2} ${RAW_TS:8:2}:${RAW_TS:10:2}:${RAW_TS:12:2}"
              else
                  echo "Output folder exists but no SQL bundle found."
              fi
          else
              echo "Output folder does not exist yet."
          fi

          # 3. Determine Diff Range
          if [ -z "$LAST_RELEASE_TS" ]; then
              echo "Result: Processing all history."
              # Use the very first commit hash
              START_POINT=$(git rev-list --max-parents=0 HEAD)
              DIFF_RANGE="$START_POINT..HEAD"
          else
              echo "Result: Processing changes since $LAST_RELEASE_TS"
              # Important: use --since to capture everything after that timestamp
              DIFF_RANGE="$LAST_RELEASE_TS"
              # DIFF_RANGE="--since=\"$LAST_RELEASE_TS\""
          fi

          TIMESTAMP=$(date +"%Y%m%d%H%M%S")
          OUTPUT_FILE="Output/${TIMESTAMP}__ReleaseBundle.sql"
          mkdir -p Output
          
          # 3. Identify changed files (Fixed Expansion)
          if [ -z "$LAST_RELEASE_TS" ]; then
              # If first run, use the START_POINT..HEAD syntax
              FILES=$(git log $DIFF_RANGE --name-only --pretty=format: | sort -u)
              COMMIT_TITLES=$(git log $DIFF_RANGE --no-merges --pretty=format:"* [\`%h\`](https://github.com/${{ github.repository }}/commit/%H) - %s" | grep -v "Auto-generated SQL bundle" | sort -u)
          else
              # If subsequent run, use --since with strict quoting
              FILES=$(git log --since="$DIFF_RANGE" --name-only --pretty=format: | sort -u)
              COMMIT_TITLES=$(git log --since="$DIFF_RANGE" --no-merges --pretty=format:"* [\`%h\`](https://github.com/${{ github.repository }}/commit/%H) - %s" | grep -v "Auto-generated SQL bundle" | sort -u)
          fi
          
          # 2. Identify changed files
          # Note: We use 'origin/Release' to ensure we see what's on the server
          #FILES=$(git log $DIFF_RANGE --name-only --pretty=format: | sort -u)

          # Initialize counters
          SP_COUNT=0
          DATA_COUNT=0
          ERRORS=0

          echo "### SQL Processing Report" >> $GITHUB_STEP_SUMMARY
          echo "| File Type | Status | File Name |" >> $GITHUB_STEP_SUMMARY
          echo "| :--- | :--- | :--- |" >> $GITHUB_STEP_SUMMARY

          for FILE in $FILES; do
              # Skip if file doesn't exist (deleted) or isn't in our target folders
              if [ -z "$FILE" ] || [ ! -f "$FILE" ]; then continue; fi
              
              # --- STORED PROCEDURES ---
              if [[ $FILE == *"SP/"* && $FILE == *.sql ]]; then
                  # Clean Windows line endings for reliable regex matching
                  CONTENT=$(cat "$FILE" | tr -d '\r' | sed -e :a -e '/^\n*$/{$d;N;ba' -e '}')
                  
                  # Validation for CREATE OR ALTER PROCEDURE
                  if [[ ! "$CONTENT" =~ ([[:space:]]*(GO)?)*[[:space:]]*CREATE[[:space:]]+OR[[:space:]]+ALTER[[:space:]]+PROCEDURE ]]; then
                      echo "| SP | FAILED | $FILE |" >> $GITHUB_STEP_SUMMARY
                      echo "::error::Validation Failed: $FILE is missing 'CREATE OR ALTER PROCEDURE'."
                      ERRORS=$((ERRORS + 1))
                      continue
                  fi

                  # Clean any extra "GO"s just for neatness
                  CONTENT=$(echo "$CONTENT" | sed 's/[[:space:]]*GO[[:space:]]*$//I')
                  
                  {
                      echo -e "-- SP/$(basename "$FILE") (Diff)\nGO\n"
                      echo "$CONTENT"
                      echo -e "\n"
                  } >> "$OUTPUT_FILE"
                  
                  SP_COUNT=$((SP_COUNT + 1))
                  echo "| SP | Added | $FILE |" >> $GITHUB_STEP_SUMMARY

              # --- DATA SCRIPTS (Data/ folder) ---
              elif [[ $FILE == *"Data/"* && $FILE == *.sql ]]; then
                  # Get just the diffs since that timestamp
                  DIFF_CHANGES=$(git log $DIFF_RANGE -p --unified=0 "$FILE" | grep -E '^\+' | grep -Ev '^\+\+\+' | sed 's/^+//g')
                  
                  if [ -n "$DIFF_CHANGES" ]; then
                      {
                          echo -e "-- Data/$(basename "$FILE") (Diff)\nGO\n"
                          echo "$DIFF_CHANGES"
                          echo -e "\n"
                      } >> "$OUTPUT_FILE"
                      
                      DATA_COUNT=$((DATA_COUNT + 1))
                      echo "| Data | Diffed | $FILE |" >> $GITHUB_STEP_SUMMARY
                  fi
              fi
          done

          # Final Summary Logic
          echo -e "\n**Processing Results:**" >> $GITHUB_STEP_SUMMARY
          echo "- Stored Procedures added: $SP_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "- Data scripts diffed: $DATA_COUNT" >> $GITHUB_STEP_SUMMARY
          
          if [ $ERRORS -gt 0 ]; then
              echo "- Validation Errors: $ERRORS" >> $GITHUB_STEP_SUMMARY
              echo "Script execution terminated due to validation failure."
              exit 1
          fi

          # Set output variables for use in subsequent steps
          echo "SP_COUNT=$SP_COUNT" >> $GITHUB_OUTPUT
          echo "DATA_COUNT=$DATA_COUNT" >> $GITHUB_OUTPUT
          
          # Final Summary Logic
          echo -e "\n**Files created on release:**" >> $GITHUB_STEP_SUMMARY
          
          # Construct the URL to the file in the Release branch
          # Replace 'YOUR_ORG' and 'YOUR_REPO' with your actual names if not dynamic
          FILE_URL="https://github.com/${{ github.repository }}/blob/Release/${OUTPUT_FILE}"
          
          echo "- Combined SQL file: [${OUTPUT_FILE}](${FILE_URL})" >> $GITHUB_STEP_SUMMARY
          
          # Extract unique commit titles since the last release
          #COMMIT_TITLES=$(git log $DIFF_RANGE --no-merges --pretty=format:"* [\`%h\`](https://github.com/${{ github.repository }}/commit/%H) - %s" | grep -v "Auto-generated SQL bundle" | sort -u)

          # Append to the summary
          echo "### Change Log (Since Last Release)" >> $GITHUB_STEP_SUMMARY
          if [ -n "$COMMIT_TITLES" ]; then
            echo "$COMMIT_TITLES" >> $GITHUB_STEP_SUMMARY
          else
            echo "*No new commit messages found.*" >> $GITHUB_STEP_SUMMARY
          fi
          echo -e "\n---\n" >> $GITHUB_STEP_SUMMARY

      - name: Commit and Push
        if: success() && (steps.process_sql.outputs.SP_COUNT > 0 || steps.process_sql.outputs.DATA_COUNT > 0)
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          branch: Release  # Force the commit to go to your Release branch
          commit_message: "Auto-generated SQL bundle [SP: ${{ steps.process_sql.outputs.SP_COUNT }}, Data: ${{ steps.process_sql.outputs.DATA_COUNT }}]"
          file_pattern: 'Output/*.sql'
          # Optional: ensures the local branch is up to date before pushing
          push_options: '--force'